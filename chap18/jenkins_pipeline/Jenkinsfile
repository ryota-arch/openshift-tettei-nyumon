pipeline {
  agent {
    kubernetes {
      cloud 'openshift'
      yaml '''\
apiVersion: v1
kind: Pod
spec:
  serviceAccountName: jenkins
  # Jenkins エージェントのワークスペースは /home/jenkins/agent
  # -> PV に依存せず emptyDir を共有して権限起因の失敗を回避
  volumes:
    - name: ws
      emptyDir: {}

  containers:
    # Jenkins と接続する JNLP コンテナ（Java 17 必須）
    - name: jnlp
      image: jenkins/inbound-agent:latest-jdk17
      # ここはデフォルト引数（JENKINS_SECRET/JENKINS_NAME）で OK
      args: ['$(JENKINS_SECRET)', '$(JENKINS_NAME)']
      env:
        - name: JENKINS_URL
          value: "http://jenkins:8080/"
        - name: NODE_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
      volumeMounts:
        - name: ws
          mountPath: /home/jenkins/agent

    # ビルド/テスト用の Maven コンテナ（Java 17）
    - name: maven
      image: maven:3.9.6-eclipse-temurin-17
      command: ["cat"]
      tty: true
      env:
        - name: NODE_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
      volumeMounts:
        - name: ws
          mountPath: /home/jenkins/agent

    # テスト用 PostgreSQL
    - name: postgres
      image: image-registry.openshift-image-registry.svc:5000/openshift/postgresql:12
      env:
        - { name: POSTGRESQL_USER,     value: 'freelancer' }
        - { name: POSTGRESQL_PASSWORD, value: 'password' }
        - { name: POSTGRESQL_DATABASE, value: 'freelancerdb_test' }
        - name: NODE_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
      volumeMounts:
        - name: ws
          mountPath: /home/jenkins/agent
'''.stripIndent()
    }
  }

  parameters {
    booleanParam(name: 'FORCE_FULL_BUILD', defaultValue: false, description: 'main 以外でも Image Build/Deploy を実行する')
  }

  environment {
    deploy_branch = "origin/main"
    deploy_project = "user-app"
    app_name = 'tettei-nyumon'
    app_image = "image-registry.openshift-image-registry.svc:5000/${deploy_project}/${app_name}"
  }

  stages {
    stage('Checkout') {
      steps {
        checkout scm
      }
    }

    stage('Application build') {
      steps {
        dir('chap18/jenkins_pipeline') {
          container('maven') {
            sh 'mvn -version'
            sh 'mvn clean package -DskipTests'
            // ここで @tmp を作成＆ 1777 にしておく（この後、postgres など別UIDのコンテナでも書けるように）
            sh '''
              set -eux
              : "${WORKSPACE:=/home/jenkins/agent/workspace}"
              # ジョブの実ワークスペースは $WORKSPACE/<job> なので cd しておくと確実
              cd "$WORKSPACE" || true
              mkdir -p "$WORKSPACE/@tmp"
              chmod 1777 "$WORKSPACE" "$WORKSPACE/@tmp"
　　　　　　　'''
          }
        }
      }
    }

    stage('Application test') {
      steps {
        container('postgres') {
          dir('chap18/jenkins_pipeline') {
            sh "PGPASSWORD=password psql -U freelancer -d freelancerdb_test -h 127.0.0.1 -f etc/testdata.sql"
          }
        }
        container('maven') {
          dir('chap18/jenkins_pipeline') {
            // 念のための保険（@tmp 未作成時の権限エラー回避）
            sh '''
              set -eux
              mkdir -p "$WORKSPACE/@tmp"
              chmod -R a+rwx "$WORKSPACE/@tmp"
              chmod a+rx "$WORKSPACE"
            '''
            sh 'mvn test'
            junit allowEmptyResults: true,
                  keepLongStdio: true,
                  healthScaleFactor: 2.0,
                  testResults: '**/target/surefire-reports/TEST-*.xml'
          }
        }
      }
    }

    stage('Image Build') {
      when { expression { env.GIT_BRANCH == "${deploy_branch}" || params.FORCE_FULL_BUILD } }
      steps {
        echo "Building OpenShift container image on node ${env.NODE_NAME}"
        dir('chap18/jenkins_pipeline') {
          script {
            openshift.withCluster() {
              openshift.withProject("${deploy_project}") {
                openshift.apply(openshift.process(
                  '-f', 'openshift/application-build.yaml',
                  '-p', "NAME=${app_name}"
                ))
                openshift.selector("bc", "${app_name}")
                  .startBuild("--from-file=./target/freelancer-service.jar", "--wait=true")
                openshift.tag("${app_name}:latest", "${app_name}:${env.GIT_COMMIT}")
              }
            }
          }
        }
      }
    }

    stage('Application deploy') {
      when { expression { env.GIT_BRANCH == "${deploy_branch}" || params.FORCE_FULL_BUILD } }
      steps {
        echo "Deploying from node ${env.NODE_NAME}"
        dir('chap18/jenkins_pipeline') {
          script {
            openshift.withCluster() {
              openshift.withProject("${deploy_project}") {
                openshift.apply(openshift.process(
                  '-f', 'openshift/application-deploy.yaml',
                  '-p', "NAME=${app_name}",
                  '-p', "APP_IMAGE=${app_image}",
                  "-p", "APP_IMAGE_TAG=${env.GIT_COMMIT}"
                ))

                def dc = openshift.selector("dc", "${app_name}").object()
                def dc_version = dc.status.latestVersion
                echo "Waiting for RC ${app_name}-${dc_version} to be ready"
                def rc
                timeout(time: 10, unit: 'MINUTES') {
                  waitUntil {
                    rc = openshift.selector("rc", "${app_name}-${dc_version}").object()
                    def desired = rc?.spec?.replicas ?: 0
                    def ready   = rc?.status?.readyReplicas ?: 0
                    echo "Node=${env.NODE_NAME} Desired=${desired} Ready=${ready}"
                    desired > 0 && ready >= desired
                  }
                }
              }
            }
          }
        }
      }
    }

    stage('Application integration test') {
      when { expression { env.GIT_BRANCH == "${deploy_branch}" || params.FORCE_FULL_BUILD } }
      steps {
        script {
          openshift.withCluster() {
            openshift.withProject("${deploy_project}") {
              def route = openshift.selector("route", "${app_name}").object()
              def url = "http://${route.spec.host}"
              echo "Probing ${url}/hello from ${env.NODE_NAME}"
              timeout(time: 5, unit: 'MINUTES') {
                waitUntil {
                  def code = sh(returnStdout: true,
                                script: "curl ${url}/hello -o /dev/null -w '%{http_code}' -s || true").trim()
                  echo "HTTP ${code}"
                  code == "200"
                }
              }
            }
          }
        }
      }
    }
  }

  post {
    always {
      echo "Pipeline finished on node: ${env.NODE_NAME} (result: ${currentBuild.currentResult})"
    }
  }
}
