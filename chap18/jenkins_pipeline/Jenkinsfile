pipeline {
  // === Agent: Kubernetes on OpenShift ===
  agent {
    kubernetes {
      cloud 'openshift'
      yaml """\
        apiVersion: v1
        kind: Pod
        spec:
          serviceAccountName: jenkins
          containers:
            - name: jnlp
              image: image-registry.openshift-image-registry.svc:5000/jenkins/custom-jenkins-agent
              args: ['\\$(JENKINS_SECRET)', '\\$(JENKINS_NAME)']
            - name: postgres
              image: image-registry.openshift-image-registry.svc:5000/openshift/postgresql:12
              env:
                - name: POSTGRESQL_USER
                  value: 'freelancer'
                - name: POSTGRESQL_PASSWORD
                  value: 'password'
                - name: POSTGRESQL_DATABASE
                  value: 'freelancerdb_test'
        """.stripIndent()
    }
  }

  environment {
    deploy_branch = "origin/main"
    deploy_project = "user-app"
    app_name = 'tettei-nyumon'
    app_image = "image-registry.openshift-image-registry.svc:5000/${deploy_project}/${app_name}"
  }

  stages {
    stage('Application build') {
      steps {
        dir('chap18/jenkins_pipeline') {
          sh 'mvn -version'
          sh 'mvn clean package -DskipTests'
        }
      }
    }

    stage('Application test') {
      steps {
        dir('chap18/jenkins_pipeline') {
          sh 'PGPASSWORD=password psql -U freelancer -d freelancerdb_test -h localhost -f etc/testdata.sql'
          sh 'mvn test'
          junit allowEmptyResults: true,
                keepLongStdio: true,
                healthScaleFactor: 2.0,
                testResults: '**/target/surefire-reports/TEST-*.xml'
        }
      }
    }

    stage('Image Build') {
      when {
        expression { env.GIT_BRANCH == "${deploy_branch}" || params.FORCE_FULL_BUILD }
      }
      steps {
        echo "Building OpenShift container image"
        dir('chap18/jenkins_pipeline') {
          script {
            openshift.withCluster() {
              openshift.withProject("${deploy_project}") {
                openshift.apply(openshift.process('-f', 'openshift/application-build.yaml', '-p', "NAME=${app_name}"))
                openshift.selector("bc", "${app_name}").startBuild("--from-file=./target/freelancer-service.jar", "--wait=true")
                openshift.tag("${app_name}:latest", "${app_name}:${env.GIT_COMMIT}")
              }
            }
          }
        }
      }
    }

    stage('Application deploy') {
      when {
        expression { env.GIT_BRANCH == "${deploy_branch}" || params.FORCE_FULL_BUILD }
      }
      steps {
        echo "deploy"
        dir('chap18/jenkins_pipeline') {
          script {
            openshift.withCluster() {
              openshift.withProject("${deploy_project}") {
                openshift.apply(openshift.process(
                  '-f', 'openshift/application-deploy.yaml',
                  '-p', "NAME=${app_name}",
                  '-p', "APP_IMAGE=${app_image}",
                  '-p', "APP_IMAGE_TAG=${env.GIT_COMMIT}"
                ))

                def dc = openshift.selector("dc", "${app_name}").object()
                def dc_version = dc.status.latestVersion
                echo "Waiting for ReplicationController ${app_name}-${dc_version} to be ready"

                def rc
                timeout(time: 10, unit: 'MINUTES') {
                  waitUntil {
                    rc = openshift.selector("rc", "${app_name}-${dc_version}").object()
                    (rc?.spec?.replicas ?: 0) == (rc?.status?.readyReplicas ?: 0)
                  }
                }
              }
            }
          }
        }
      }
    }

    stage('Application integration test') {
      when {
        expression { env.GIT_BRANCH == "${deploy_branch}" || params.FORCE_FULL_BUILD }
      }
      steps {
        script {
          openshift.withCluster() {
            openshift.withProject("${deploy_project}") {
              def route = openshift.selector("route", "${app_name}").object()
              def url = route.spec.host
              echo "Route: ${url}"

              timeout(time: 5, unit: 'MINUTES') {
                waitUntil {
                  def code = sh(returnStdout: true, script: "curl http://${url}/hello -o /dev/null -w '%{http_code}' -s || echo 000").trim()
                  return code == "200"
                }
              }
            }
          }
        }
      }
    }
  }

  post {
    always {
      script {
        def nodeName = env.NODE_NAME ?: 'unknown'
        echo "Pipeline finished on node: ${nodeName}"
      }
      cleanWs()
    }
    failure {
      echo "Pipeline failed."
    }
    success {
      echo "Pipeline succeeded."
    }
  }
}
